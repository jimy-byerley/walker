use std::{
    cell::RefCell,
    rc::Rc,
};
use bilge::prelude::*;
use crate::i2c::{Slave, Register};


/// high level control interface for TCS3472x color sensor
pub struct TCS3472<I2C: embedded_hal::i2c::I2c> {
    pub slave: Slave<I2C>,
}
impl<I2C:embedded_hal::i2c::I2c> TCS3472<I2C>
{
    pub fn new(bus: Rc<RefCell<I2C>>, address: u8) -> Self {
        Self{slave: Slave::new(bus, address)}
    }
}


/// fixed addresses of TCS3472x devices
pub mod address {
    pub const TCS34721: u8 = 0x39;
    pub const TCS34723: u8 = 0x39;
    pub const TCS34725: u8 = 0x29;
    pub const TCS34727: u8 = 0x29;
}
/// low level access to the sensor's i2c registers
pub mod registers {
    use super::*;

    /**
        Enable Register (0x00)
        The Enable register is used primarily to power the TCS3472 device on and off, and enable functions and
        interrupts as shown in Table 5.
     */
    pub const ENABLE: Register<Enable> = Register::new(0x00);

    /**
        RGBC Timing Register (0x01)
        The RGBC timing register controls the internal integration time of the RGBC clear and IR channel ADCs in
        2.4-ms increments. Max RGBC Count = (256 − ATIME) × 1024 up to a maximum of 65535.
    */
    pub const ATIME: Register<u8> = Register::new(0x01);
    /**
        Wait Time Register (0x03)
        Wait time is set 2.4 ms increments unless the WLONG bit is asserted, in which case the wait times are 12×
        longer. WTIME is programmed as a 2’s complement number.
     */
    pub const WTIME: Register<u8> = Register::new(0x03);

    /**
        RGBC Interrupt Threshold Registers (0x04 − 0x07)
        The RGBC interrupt threshold registers provides the values to be used as the high and low trigger points for
        the comparison function for interrupt generation. If the value generated by the clear channel crosses below the
        lower threshold specified, or above the higher threshold, an interrupt is asserted on the interrupt pin.
     */
    pub const AIT: Register<InterruptThreshold> = Register::new(0x04);

    /**
        Persistence Register (0x0C)
        The persistence register controls the filtering interrupt capabilities of the device. Configurable filtering is
        provided to allow interrupts to be generated after each integration cycle or if the integration has produced a result
        that is outside of the values specified by the threshold register for some specified amount of time.
     */
    pub const PERS: Register<u8> = Register::new(0x0c);
    /**
        Configuration Register (0x0D)
        The configuration register sets the wait long time.
     */
    pub const CONFIG: Register<u8> = Register::new(0x0d);
    /**
        Control Register (0x0F)
        The Control register provides eight bits of miscellaneous control to the analog block. These bits typically control
        functions such as gain settings and/or diode selection.
     */
    pub const CONTROL: Register<u8> = Register::new(0x0F);
    ///  Part number identification
    pub const ID: Register<Id> = Register::new(0x12);
    /**
        Status Register (0x13)
        The Status Register provides the internal status of the device. This register is read only.
     */
    pub const STATUS: Register<u8> = Register::new(0x13);

    /**
        RGBC Channel Data Registers (0x14 − 0x1B)
        Clear, red, green, and blue data is stored as 16-bit values. To ensure the data is read correctly, a two-byte read
        I2C transaction should be used with a read word protocol bit set in the command register. With this operation,
        when the lower byte register is read, the upper eight bits are stored into a shadow register, which is read by a
        subsequent read to the upper byte. The upper register will read the correct value even if additional ADC
        integration cycles end between the reading of the lower and upper registers.
     */
    pub const CRGB: Register<Color> = Register::new(0x14);
    /// access to individual components
    pub const C: Register<u16> = Register::new(0x14);
    pub const R: Register<u16> = Register::new(0x16);
    pub const G: Register<u16> = Register::new(0x18);
    pub const B: Register<u16> = Register::new(0x1A);

    #[bitsize(8)]
    pub struct Enable {
        _reserved1: u3,
        /// RGBC interrupt enable. When asserted, permits RGBC interrupts to be generated.
        pub rgbc_interrupt: bool,
        /// Wait enable. This bit activates the wait feature. Writing a 1 activates the wait timer. Writing a 0 disables the wait timer.
        pub wait: bool,
        _reserved2: u1,
        /// RGBC enable. This bit actives the two-channel ADC. Writing a 1 activates the RGBC. Writing a 0 disables the RGBC.
        pub rgbc: bool,
        /// Power ON. This bit activates the internal oscillator to permit the timers and ADC channels to operate.
        /// Writing a 1 activates the oscillator. Writing a 0 disables the oscillator.
        pub power_on: bool,
    }
    #[bitsize(32)]
    pub struct InterruptThreshold {
        pub low: u16,
        pub high: u16,
    }
    #[bitsize(8)]
    #[derive(FromBits, DebugBits, PartialEq, Default)]
    pub struct Config {
        _reserved1: u6,
        pub wait_long: bool,
        _reserved2: u1,
    }
    #[bitsize(8)]
    #[derive(FromBits, DebugBits, PartialEq, Default)]
    pub struct Control {
        _reserved1: u6,
        pub gain: u2,
    }
    #[bitsize(8)]
    #[derive(FromBits, Debug, PartialEq, Default)]
    #[allow(non_camel_case_types)]
    pub enum Id {
        #[fallback]
        #[default]
        Undefined = 0,
        TCS34721_or_TCS34725 = 0x44,
        TCS34723_or_TCS34727 = 0x4d,
    }
    #[bitsize(8)]
    #[derive(FromBits, DebugBits, PartialEq, Default)]
    pub struct Status {
        _reserved1: u3,
        /// RGBC clear channel Interrupt.
        pub interrupt: bool,
        _reserved2: u3,
        /// RGBC Valid. Indicates that the RGBC channels have completed an integration cycle.
        pub valid: bool,
    }

    #[bitsize(64)]
    #[derive(FromBits, DebugBits, PartialEq, Default)]
    pub struct Color {
        c: u16,
        r: u16,
        g: u16,
        b: u16,
    }
}
